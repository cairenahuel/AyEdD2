\documentclass[10pt,a4paper]{article}
\usepackage{tabularx}
\usepackage{amssymb}
\usepackage{enumitem}
\input{../AEDmacros.tex}
\input{../nahuelMacros.tex}
\begin{document}
\section*{Especificacion de TADs}
\tbft{Ejercicio 1}{Especificar en forma completa el TAD \texttt{NumeroRacional} que incluya al menos las operaciones aritmeticas basicas}
\begin{tad}{NumeroRacional}
    \obs{n}{\ent}
    \obs{d}{\ent}
    \begin{proc}{suma}{\In a,b: \nombretad}{\nombretad}
        \requiere{true}
        \asegura{res=\frac{a.n*b.d+a.d*b.n}{b.d*a.d}}
    \end{proc}
    \begin{proc}{resta}{\In a,b: \nombretad}{\nombretad}
        \requiere{true}
        \asegura{res=\frac{a.n*b.d-a.d*b.n}{b.d*a.d}}
    \end{proc}
    \begin{proc}{multiplicacion}{\In a,b: \nombretad}{\nombretad}
        \requiere{true}
        \asegura{res=\frac{a.n*b.n}{b.d*a.d}}
    \end{proc}
    \begin{proc}{division}{\In a,b: \nombretad}{\nombretad}
        \requiere{b\not= 0}
        \asegura{res=\frac{a.n*b.d}{b.n*a.d}}
    \end{proc}
\end{tad}
\tbft{Ejercicio 2:}{Especificar TADs para las siguientes figuras geometricas. Tiene que contener las operaciones rotar, trasladar y escalar, y una mas propuesta por usted.}
\begin{itemize}
    \item Rectangulo (2D)
    \item Esfera (3D)
\end{itemize}
\begin{tad}{Rectangulo}
    \obs{alto}{\float}
    \obs{ancho}{\float}
    \obs{posicion}{$\langle\float\times\float\rangle$}
    \obs{angulo}{\float}
    \begin{proc}{nuevo\nombretad}{\In h: \float, \In w: float, \In x:\float,\In y:\float}{\nombretad}
        \requiere{w \geq 0 \land h \geq 0}
        \asegura{res.ancho=w \land res.alto=h \land res.posicion=(x,y) \land r.angulo=0}
    \end{proc}
    \begin{proc}{escalar}{\Inout r: \nombretad, mh:\float, mw:\float}{}
        \requiere{r=R_0}
        \asegura{(mw\geq0 \land mh \geq0) \yLuego r.posicion=R_0.posicion }
        \asegura{r.alto=|R_0.alto*mh| \land r.ancho=|R_0.ancho*mw|}
        \asegura{mw<0 \yLuego r.posicion_1=R_0.posicion_1+R_0.ancho*mw}
        \asegura{mh<0 \yLuego r.posicion_2=R_0.posicion_2+R_0.alto*mh}
    \end{proc}
    \begin{proc}{rotar}{\Inout r: \nombretad, \In rad: \float}{}
        \requiere{r=R_0}
        \asegura{r.angulo=R_0.angulo+rad}
    \end{proc}
    \begin{proc}{trasladar}{\Inout r: \nombretad, \In pos: $\langle x,y\rangle$}{}
        \requiere{r=R_0}
        \asegura{r.posicion=R_0.posicion+pos}
    \end{proc}
    \begin{proc}{area}{\In r: \nombretad}{\float}
        \asegura{res=r.alto \cdot r.ancho}
    \end{proc}
\end{tad}
\pagebreak
\begin{tad}{Esfera}
    \obs{radio}{\float}
    \obs{centro}{$\langle \float\times\float\times\float \rangle$}
    %\vspace*{0.5em}
    %\noindent Por claridad de notacion $centro_x$, $centro_y$ y $centro_z$ seran\\usadas en lugar de sus variantes con numero.
    \obs{semieje}{$\langle \float\times\float\times\float \rangle$}
    \begin{proc}{nueva\nombretad}{\In r: \float, \In pos:$\langle \float\times\float\times\float \rangle$}{\nombretad}
        \asegura{res.radio={|r|}}
        \asegura{res.centro=pos}
    \end{proc}
    \begin{proc}{escalar}{\Inout esfera: \nombretad, \In e: \float}{}
        \requiere{esfera=esfera_0}
        \asegura{esfera.radio=ESFERA_0.radio*|e|}
    \end{proc}
    \begin{proc}{trasladar}{\Inout esfera: \nombretad, \In pos:$\langle x,y,z\rangle$}{}
        \requiere{esfera=ESFERA_0}
        \asegura{esfera.centro=ESFERA_0.centro+pos}
    \end{proc}
    \begin{proc}{rotar}{\Inout esfera: \nombretad, \In angulosrad: $\langle \alpha,\beta,\gamma \rangle$}{}
        \requiere{esfera=ESFERA_0}
        \asegura{esfera.semieje=ESFERA_0.semieje+angulosrad}
    \end{proc}
\end{tad}
\ejercicio{3}{Especifique el TAD DobleCola\slr{T}, en el que los elementos pueden insertarse al principio o al final y se eliminan por el medio.}
\begin{tad}{DobleCola}
    \obs{elems}{\TLista{T}}
    \begin{proc}{\nombretad Vacia}{}{\nt}
        \asegura{res=\slr{}}
    \end{proc}
    \begin{proc}{encolarFinal}{\Inout doblecola: \nt, \In e: T}{}
        \requiere{doblecola=DOBLECOLA_0}
        \asegura{doblecola.elems=concat(DOBLECOLA_0.elems, \langle e\rangle)}
    \end{proc}
    \begin{proc}{encolarInicio}{\Inout doblecola: \nt, \In e: T}{}
        \requiere{doblecola=DOBLECOLA_0}
        \asegura{doblecola.elems=concat(\langle e\rangle,DOBLECOLA_0.elems)}
    \end{proc}
    \begin{proc}{desencolar}{\Inout doblecola: \nt}{T}
        \requiere{doblecola=DOBLECOLA_0}
        \requiere{cola.elems\not=\slr{}}
        \asegura{res\not \in doblecola.elems}
        \asegura{res=DOBLECOLA_0.elems\Biggl[\Bigl\lceil{\frac{|DOBLECOLA_0|}{2}}\Bigr\rceil\Biggr]}
    \end{proc}
\end{tad}
\pagebreak
\ejercicio{4}{Especifique el TAD DiccionarioConHistoria. El mismo guarda para cada clave, todos los valores que se asociaron con la misma a lo largo del tiempo (en orden)}
\begin{tad}{DiccionarioConHistoria\<T,\TLista{K}\>}
    \obs{data}{dict<T,\TLista{K}>}
    \begin{proc}{\nt Vacio}{}{\nt}
        \asegura{res.data=\{\}}
    \end{proc}
    \begin{proc}{estaLaLlave}{\In dic:\nt, \In e: T}{\bool}
        \asegura{res=true \siiLargo e \in dic.data}
    \end{proc}
    \begin{proc}{definir}{\Inout dic: \nt,\In k: T, \In e: K}{}
        \requiere{DIC_0=dic \yLuego k \in RES_0.data}
        \asegura{dic.data[k][0]=setKey(DIC_0.data,k,concat(DIC_0.data[k],e))}
    \end{proc}
    \begin{proc}{consultarHistorial}{\In dic: \nt, \In k: T}{\TLista{K}}
        \asegura{res=res.data[k]}
    \end{proc}
    \begin{proc}{borrar}{\Inout dic \nt,\In k: T}{}
        \requiere{dic=DIC_0}
        \requiere{k\in dic.data}
        \asegura{dic.data=delKey(DIC_0, k)}
    \end{proc}
    \begin{proc}{tamaño}{\In dic: \nt}{\ent}
        \asegura{res=|dic.data|}
    \end{proc}
\end{tad}
\ejercicio{5}{Modifique el TAD ColaDePrioridad<T> para que, si hay muchos valores iguales al maximo, la operacion desapilarMax los desapile a todos.}
\begin{tad}{ColaDePrioridad\textless T\textgreater}
    ---Toda la implementacion normal de \nt ---
    \begin{proc}{desapilarMax}{\Inout cola:\nt}{\TLista{T}}
        \requiere{cola=COLA_0}
        \asegura{\not \exists\ e \in cola.data, \exists e' \in COLA_0.data: tienePriMax(COLA_0.data, e') \yLuego cola.data[e] = COLA_0.data[e']}
        \asegura{(\forall e \in COLA_0.data)\ (tienePriMax(COLA_0.data, e) \yLuego e \in res)\lor\\ (\lnot tienePriMax(COLA_0.data, e) \yLuego e\not\in res)}
        {\color{red}\asegura{|res|=|COLA_0.data|-|cola.data|}}
    \end{proc}
\end{tad}
\\\texttt{\color{red}No estoy seguro de si se puede usar el operando $\in$ con diccionarios, ni si estoy asegurando que TODOS los 
elementos que saco de la cola sean incluidos en la sequencia de resultado, por ejemplo si tengo dos elementos en la cola con el 
mismo nombre y la misma prioridad, ambos van a la secuencia con la definicion que di? creo que no, que como uno ya pertenece el otro 
no necesariamente se agrega. ¿Comparar la cantidad que saco y el largo de la secuencia puede ser una opcion valida?}
\ejercicio{6}{Especifique los TADS indicados a continuacion pero utilizando los observadores propuestos}
\begin{itemize}
    \item Diccionario\smm{K,V} observando con conjuntos (de tuplas)
    \item Conjunto\smm{T} observando con funciones
    \item Pila\smm{T} observando con diccionarios
    \item Punto observando con coordenadas polares
\end{itemize}
\pagebreak
\begin{tad}{Diccionario\smm{K,V}}
    \obs{datos}{conj\slr{K\times V}}
    \begin{proc}{diccionarioVacio}{}{\nt}
        \asegura{res.datos=\{\}}
    \end{proc}
    \begin{proc}{agregar}{\Inout dic: \nt, \In k: K, \In v: V}{}
        \requiere{dic=DIC_0}
        \asegura{(k,v) \in dic.datos}
    \end{proc}
    {\color{red}---Se puede hacer siquiera esto? Otro observador con otro conjunto de tuplas
     y apariciones? raro}
\end{tad}
\salto{\baselineskip}
\begin{tad}{Conjunto\smm{T}}
    \obs{pertenece}{\bool}
    \obs{largo}{\ent}
    \begin{proc}{conjVacio}{}{\nt}
        \requiere{true}
        \asegura{res.largo=0}
    \end{proc}
    \begin{proc}{agregar}{\Inout c: \nt, \In e: T}{}
        \requiere{c=C_0}
        \asegura{c.pertenece(e)}
    \end{proc}
    \begin{proc}{sacar}{\Inout c: \nt, \In e: T}{}
        \requiere{c=C_0}
        \asegura{\lnot c.pertenece(e)}
    \end{proc} 
    \begin{proc}{unir}{\Inout c: \nt, \In c': \nt}{}
        \requiere{c=C_0}
        \asegura{\forall e \in T, c'.pertenece(e): c.pertenece(e)}
    \end{proc}
    \begin{proc}{restar}{\Inout c: \nt, \In c': \nt}{}
        \requiere{c=C_0}
        \asegura{\forall e \in T, c'.pertenece(e): \lnot c.pertenece(e)}
    \end{proc}
    \begin{proc}{intersecar}{\Inout c: \nt, \In c': \nt}{}
        \requiere{c=C_0}
        \asegura{\forall e \in T, C_0.pertenece(e) \land c'.pertenece(e) \sii c.pertenece(e)}
    \end{proc}
    \begin{proc}{tamaño}{\In c: \nt}{\nat}
        \requiere{true}
        \asegura{\exists! m \in \ent: \sum_{i=1}^{m}\IfThenElse{c.pertenece(e)}{1}{0}=res, e\in T}
        {\color{red} --- acá cree el observador largo porque muchas cosas raras tenia que hacer}
        \\\asegura{res=c.largo}
    \end{proc}
\end{tad}
\salto{\baselineskip}
\begin{tad}{Pila\smm{T}}
    \obs{elems}{dict\smm{\nat,T}}
    \begin{proc}{pilaVacia}{}{\nt}
        \requiere{true}
        \asegura{res.elems=\{\}}
    \end{proc}
    \begin{proc}{vacia}{\In pila: \nt}{\bool}
        \requiere{true}
        \asegura{res=true\sii pila.elems=\{\}}
    \end{proc}
    \begin{proc}{apilar}{\Inout pila: \nt, \In e: T}{}
        \requiere{pila=PILA_0}
        \asegura{|PILA_0.elems|+1=|pila.elems| \land |pila.elems|\in pila.elems \yLuego setKey(pila.elems, |pila.elems|, e)}
    \end{proc}
    \pagebreak
    \begin{proc}{desapilar}{\Inout pila: \nt}{T}
        \requiere{pila=PILA_0}
        \requiere{pila.elems\not=\{\}}
        \asegura{|pila.elems|=|PILA_0.elems|-1\land |PILA_0.elems|\not\in pila.elems}
        \asegura{res=PILA_0.elems\big[|PILA_0.elems|\big]}
    \end{proc}
    \begin{proc}{tope}{\In pila: \nt}{T}
        \requiere{pila.elems\not=\{\}}
        \asegura{res=pila.elems\big[|pila.elems|-1\big]}
    \end{proc}
\end{tad}
\salto{\baselineskip}
\begin{tad}{Punto}
    \obs{coords}{\slr{\float \times \float}}
    \pred{igualdad}{p1, p2: \nt}{(\exists k \in \ent: p1.coords_2=p2.coords_2+2k\pi)\land(p1.coords_1=p2.coords_1)}
    \begin{proc}{crearPunto}{\In r: \float, \In $\alpha$: \float}{\nt}
        \requiere{r\geq0}
        \asegura{res.coords=(r,\alpha)}
    \end{proc}
    \begin{proc}{mover}{\Inout p: \nt, \In newcoords: \slr{\float\times\float}}{}
        \requiere{true}
        \asegura{p.coords_1=newcoords_1\land p.coords_2=newcoords_2}
    \end{proc}
\end{tad}
\ejercicio{7}{Especificar TADs para las siguientes estructuras:}
\begin{itemize}
    \item Multiconjunto\smm{T} -  Es igual a un conjunto pero con duplicados. Cada elemento tiene asociada una multiplicidad,
     que es la cantidad de veces que este aparece en la estrucutra. Tiene las mismas operaciones que un conjunto y ademas una que 
     indica la multiplicidad del elemento.
     \begin{tad}{Multiconjunto}
         \obs{elems}{dict\smm{T,\nat}}
         \begin{proc}{conjuntoVacio}{}{\nt}
             \requiere{true}
             \asegura{res.elems=\{\}}
         \end{proc}
         \begin{proc}{agregar}{\Inout mc: \nt, \In e: T}{}
             \requiere{mc=MC_0}
             \asegura{e\in MC_0.elems \yLuego mc.elems[e]=MC_0.elems[e]+1}
             \asegura{e\not\in MC_0.elems \yLuego setKey(mc,e,1)}
         \end{proc}
         \begin{proc}{eliminar}{\Inout mc: \nt}{}
             \requiere{mc=MC_0}
             \asegura{e\in MC_0.elems \yLuego MC_0.elems[e]=1 \yLuego mc.elems=delKey(MC_0,e)}
             \asegura{e\in M_0.elems \yLuego MC_0.elems[e]>1 \yLuego mc.elems=setKey(MC_0,e,MC_0.elems[e]-1)}
         \end{proc}
         \begin{proc}{multiplicidad}{\In mc: \nt, \In e: T}{\ent}
             \requiere{true}
             \asegura{e \in mc \yLuego res=mc.elems[e]}
             \asegura{e\not\in mc \yLuego res=0}
         \end{proc}
         \rojo{--- Hay mas operaciones pero creo que estas son las mas relevantes}
     \end{tad}
     \pagebreak
     \item Multidict\smm{K,V}: Misma idea pero para diccionarios, cada clave puede estar asociada a multiples valores. Los valores se definen de a uno, 
     pero la operacion obtener debe devolver todos los valores asociados a una determinada clave.\\ 
     \rojo{\\Sobre la nota(que no copie): una posible implementacion que se me ocurre es la de un taller en el que las keys son los operarios y 
     los values son listas en las que estan los trabajos pendientes que le corresponden a cada uno, en una implementacion mas completa se 
     podria hacer procs para mover los trabajos de la cola (porque la secuencia va a ser basicamente una cola en su comportamiento default) 
     pero que tambien se pueda elegir trabajos especificos que hacer para darles prioridad.}
     \begin{tad}{Multidict\smm{K,V}}
         \obs{elems}{dict\smm{K,\TLista{V}}}
         \begin{proc}{multidictVacio}{}{\nt}
             \requiere{true}
             \asegura{res.elems=\{\}}
         \end{proc}
         \begin{proc}{agregar}{\Inout md: \nt, \In k: K, \In v: V}{}
             \requiere{md=MD_0}
             \asegura{k\in MD_0.elems \yLuego setKey(md.elems, k, concat(\slr{v},MD_0.elems[k]))}
             \asegura{k\not\in MD_0.elems \yLuego setKey(md.elems, k, \slr{v})}
         \end{proc}
         \begin{proc}{borrar}{\Inout md: \nt, \In k: K}{}
             \requiere{md=MD_0}
             \asegura{k\not\in MD_0 \yLuego md=MD_0}
             \asegura{k\in MD_0.elems \land |MD_0.elems|=1 \yLuego delKey(md.elems, k)}
             \asegura{k\in MD_0.elems \land |MD_0.elems|>0 \yLuego\\\hspace*{4.5em}setKey(md.elems, k, subseq(MD_0.elems, 1, |MD_0.elems|[k]))}
         \end{proc}
         \rojo{--- Creo que el resto de la implementacion es trivial, podria agregarse un booleando como parametro de borrar que determine si
          se borra la key completamente o si se borra valor a valor}
     \end{tad}
    \end{itemize}
\ejercicio{8}{Especifique el TAD contadores que, dada una lista de eventos, permite contar la cantidad de veces que se produjo cada uno de ellos.
La lista de eventos es fija. El TAD debe tener una operacion para incrementar el contador asociado a un evento y una operacion para conocer 
el valor actual del contador de dicho evento.\\
\hspace*{2em}-Modifique el TAD para que sea posible guardar el valor del contador en un determinado momento del pasado. Si necesita conocer la fecha 
y hora actual puede pasarla como parametro a los procedimientos. Asuma que las dechas son numeros enteros (por ejemplo la cantidad de segundos desde el 1ro de enero del '70)}
\begin{tad}{Contadores}
    \obs{elems}{dict\smm{T,\ent}}
\end{tad}
\end{document}